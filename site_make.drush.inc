<?php
/**
 * @file
 *   site-make drush command.
 *
 *  You can copy this file to any of the following
 *    1. A .drush folder in your HOME folder.
 *    2. Anywhere in a folder tree below an active module on your site.
 *    3. /usr/share/drush/commands (configurable)
 *    4. In an arbitrary folder specified with the --include option.
 *    5. Drupal's /drush or /sites/all/drush folders.
 */

/**
 * Implementation of hook_drush_command().
 */
function site_make_drush_command() {
  $items = array();

  $items['site-make'] = array(
    'description' => "Wrapper around drush make for (re)building site repos.",
    'arguments' => array(
      'config' => 'path/to/site-make.config.inc',
    ),
    'options' => array(
      'show-info' => array(
        'description' => 'Print $info array from combined make files. (Helpful for development.)',
      ),
      'show-config' => array(
        'description' => 'Print $config array from mysite.config.inc. (Helpful for development.)',
      ),
      'message' => array(
        'description' => 'Message to include at the beginning of any new commits.',
      ),
      'simulate' => array(
        'description' => 'Output commands to be executed for examination, but do not actually execute them.',
      ),
      // @todo
      're-add' => array(
        'description' => '@todo Remove and re-add comma separated list of subtree(s).',
      ),
    ),
    'examples' => array(
      'drush site-make mysite.config.inc' => '',
      'drush mks mysite.config.inc --show-info' => '',
      'drush mks mysite.config.inc --message="Rebuild with example_distro release 7.x-1.5"' => '',
      'drush mks mysite.config.inc --re-add=example1,example2,exampleN' => '',
    ),
    'aliases' => array('mks'),
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH, // No bootstrap at all.
  );

  $items['site-make-setup-repo'] = array(
  
    // TODO
    // Prompt:
    //   Create symlink-these directory
    //   Create/Symlink sites directory/-ies.
    //   Create/Symlink .htaccess
    //   Create/Symlink robots.txt
    //   Create mysite.config.inc
    //   Symlink build/make files
    // If site is an instance of a distro with tests:
    //   Symlink behat/travis/etc files generated by chris pliakas's drupal-distro
    //   Create testsite.config.inc (if used in build.xml)
    // 

 );

  return $items;
}

/**
 * Implementation of drush_hook_COMMAND_validate().
 */
function drush_site_make_validate($config_file) {
  $is_valid = TRUE;

  // TODO Check drush version. Currently, this requires master branch with --no-recurse option.

  // TODO Check ownership. If ant rebuilds, ownership may be funny.

  // TODO This command must be run from top-level of git repo.
  // TODO Confirm we're in a git repo.
  // cd "$(git rev-parse --show-toplevel)"

  // Confirm we have a config file.
  $is_valid = (file_exists($config_file)) ? TRUE : drush_set_error('site_make', dt('Could not find config file, !here'), array('!here' => $config_file));

  // TODO Confirm config points to a make file.
  // TODO Check code base for make files. See if they're all being included in build. If not, notify user. Ask if we should proceed or not.

  // Helper stuff.
  // TODO Check for subtrees. Give user message if not using.
  // TODO Check for commands to shell_exec. Give user message if not using.

  return $is_valid;
}

/**
 * Callback for site-make command.
 *
 * @param string $config_file
 *  path/to/config/file providing $config info
 *
 * @see drush_invoke()
 * @see drush.api.php
 */
function drush_site_make($config_file = '') {
  // Build up array of commands to be executed in order.
  $commands = array();

  // @todo Make $config_file optional. Scan directory for site_make.*.yml. If
  // more than one file exists, prompt user to select one.

  // Load config file, providing $conf variable.
  drush_log(dt('Loading configuration from: !config_file', array('!config_file' => $config_file)), 'ok');
  $config = _site_make_get_config($config_file);

  // Assemble $info array by loading, parsing and merging make file(s).
  $build_file = $config['build_file'];
  drush_log(dt('Using build file: !build_file', array('!build_file' => $build_file)), 'ok');
  $info = _site_make_get_info($build_file);

  // If requested, output full build info.
  if (drush_get_option('show-info')) {
    drush_print('$info:');
    drush_print_r($info));
  }

  // 
  // Add/update git subtrees.
  //

  // @todo Check if there are uncommitted changes locally. Exit if there are.
  // Otherwise, subtree add/pull won't work.

  // If there are subtrees in the config file, get commands for adding/updating subtrees.
  if (isset($config['subtrees'])) {

    drush_log(dt('Preparing to add/update git subtrees specified here: !config_file', array('!config_file' => $config_file)), 'ok');

    // Prep projects directory. All subtrees will use --prefix=projects/$name
    _site_make_prep_projects_directory();

    // Hang onto symlink commands here. Add these to the $commands array after drush make.
    $symlink_commands = array();

    foreach ($config['subtrees'] as $subtree_name => $details) {
      // Get project info from make file.
      $project_info = (isset($info['projects'][$subtree_name])) ? $info['projects'][$subtree_name] : array();
      // Get subtree commands.
      $subtree_commands = _site_make_get_subtree_commands($subtree_name, $details, $project_info);
      // Remove files checked out by drush. Add symlink pointing to your local subtree.
      drush_print(dt('Preparing to symlink !subtree_name to path: !path', array('!subtree_name' => $subtree_name, '!path' => $details['path'])), 'status');
      $symlink_commands[] = _site_make_subtree_add_symlink($subtree_name, $details['path']);
      // Add subtree commands to the beginning of the $commands array, to be executed before drush make.
      $commands = array_merge($commands, $subtree_commands);
    }

  }

  // Execute subtree commands now. This way, drush make will include info
  // from make files updated with git subtree pulls.
  foreach ($commands as $command) {
    // @todo Add error handling.
    drush_shell_exec($command);
  }
  // Zero out $commands. Build up next array of commands to be executed
  $commands = array();
  
  //
  // Drush make.
  //


  // If target director already exists, remove it.
  $target = $config['target'];
  if (file_exists($target)) {
    $commands[] = "rm -rf $target";
  }
  $commands[] = DRUSH_COMMAND . " make {$build_file} {$target} --no-recursion --no-gitinfofile";

  // Replace downloaded projects with symlinks where subtrees are used.
  $commands = array_merge($commands, $symlink_commands);

  //
  // Custom, site-specific commands defined by config file.
  //

  // Add custom commands from site make config file.
  foreach ($config['commands'] as $command) {
    $commands[] = $command;
  }

  //
  // Commit.
  // 

  $message = ($message = drush_get_option('message', FALSE)) ? $message : dt('Rebuild with drush site-make.');
  $commands[] = _site_make_commit($message);

  //
  // Execute commands.
  //

  foreach ($commands as $command) {
    drush_shell_exec($command);
  }

}

/**
 * Load config from config file by calling site_make_config().
 *
 * Helpful tip for developers: You can convert a PHP array to YAML via drush
 * like this. If you know the $config array you want, but you're not sure how to
 * form at it, build the array, then run it through this function:
 *
 *   drush_print(drush_format($config, NULL, 'yaml'));
 *
 * @return array $config
 */
function _site_make_get_config($config_file) {
  if (!class_exists('Symfony\Component\Yaml\Parser')) {
    // For Drush PSR-0 and Composer information, see http://drupal.org/node/1316322.
    drush_log('Autoloading Symfony\Component\Yaml\Parser failed.', 'error');
    return;
  }
  $parser = new Symfony\Component\Yaml\Parser();
  $config = $parser->parse(file_get_contents($config_file));

  // If requested, output loaded config
  if (drush_get_option('show-config', FALSE)) {
    drush_print('$config:');
    drush_print(drush_format($config, NULL, 'yaml'));
  }

  return $config;
}

/**
 * Parse make/info files.
 *
 * @return array $info
 *  Assemble $info array by loading, parsing and merging make file(s).
 */
function _site_make_get_info($file) {
  // Load $info from info/make file if it exists.
  if (file_exists($file)) {
    $info = make_parse_info_file($file);  
  }
  else {
    return drush_set_error('site_make', dt('Make file does not exist: !here.', array('!here' => $file)));
  }

  // Check for included make files. If they exist, recurse.
  $merge_info = array();
  if (isset($info['includes'])) {
    foreach ($info['includes'] as $include) {
      $more_info = _site_make_get_info($include);
      $merge_info = array_merge_recursive_distinct($merge_info, $more_info);
    }
  }

  $info = array_merge_recursive_distinct($info, $merge_info);

  return $info;
}

/**
 * http://danielsmedegaardbuus.dk/2009-03-19/phps-array_merge_recursive-as-it-should-be/
 */
function &array_merge_recursive_distinct(array &$array1, &$array2 = null)
{
  $merged = $array1;
 
  if (is_array($array2))
    foreach ($array2 as $key => $val)
      if (is_array($array2[$key]))
        $merged[$key] = is_array($merged[$key]) ? array_merge_recursive_distinct($merged[$key], $array2[$key]) : $array2[$key];
      else
        $merged[$key] = $val;
 
  return $merged;
}

/**
 * Generate git subtree add command to be run from top-level of repo.
 *
 * @param string directory
 *   Directory name where subtree should live
 *
 * @param array $details
 *   Relevant details for git subtree add command:
 *    - uri
 *    - branch
 *    - squash
 *    - message
 *
 * @return string | bool
 *   Return command to be executed. False for don't do anything.
 */
function _site_make_subtree_add($directory, $details) {
  $prefix = _site_make_get_prefix($directory);

  if (file_exists($prefix)) {
    // Subtree has already been created. Or there's a directory in our way. Skip this step.
    drush_log(dt("This directory already exists: !prefix", $prefix), array('!prefix' => $prefix), 'notice');
    drush_log(dt("Git subtree add command will be skipped. If !prefix is not a subtree, remove this directory and re-run the site-make command.", $prefix), array('!prefix' => $prefix), 'warning');
    // We're done. Return.
    return FALSE;
  }

  // Make sure we have minimum required $details.
  $uri = _site_make_get_uri($details);
  $branch =  _site_make_get_branch($details);
  if (!$uri || !$branch) {
    // We're done. Return.
    return FALSE;
  }

  // Squash commit history of subtree into a single commit?
  $squash_history = (isset($details['squash'])) ? $details['squash'] : FALSE;
  $squash = ($squash_history) ? ' --squash' : '';

  // Add custom commit message?
  $message = _site_make_add_subtree_commit_message($details);

  // Build the command to add subtree for the first time.
  $command = "git subtree add --prefix={$prefix} {$squash} {$message} $uri $branch";

  return $command;  
}

/**
 * @param array $details
 *   From site make YAML config file.
 *
 * @return string $command
 *   A commit message flag to a git subtree add, pull, or merge command.
 *   Empty string if no message should be added.
 */
function _site_make_add_subtree_commit_message($details) {
  $drush_message = drush_get_option('message', '');
  $subtree_message = (isset($details['message'])) ? $details['message'] : '';
  if ($drush_message || $subtree_message) {
    $custom_message = ($drush_message) ? "{$drush_message}\n\n\t{$subtree_message}" : $subtree_message;
  }
  $message = ($custom_message) ? " --message='{$custom_message}'" : '';

  return $message; 
}


/**
 * Generate git subtree pull command to be run from top-level of repo.
 *
 * @param string directory
 *   Directory name where subtree should live
 *
 * @param array $details
 *   Relevant details for git subtree add command:
 *    - uri
 *    - branch
 *    - squash
 *    - message
 *
 * @return string | bool
 *   Return command to be executed. False for don't do anything.
 */
function _site_make_subtree_pull($directory, $details) {
  $prefix = _site_make_get_prefix($directory);
  $uri = _site_make_get_uri($details);
  $branch =  _site_make_get_branch($details);
  $message = _site_make_add_subtree_commit_message($details);

  // Squash commit history of subtree into a single commit?
  $squash_history = (isset($details['squash'])) ? $details['squash'] : FALSE;
  $squash = ($squash_history) ? ' --squash' : '';

  $command = "git subtree pull --prefix={$prefix} {$squash} {$message} {$uri} {$branch}";

  return $command;
}

/**
 * @param string $directory
 *   Name of directory where subtree should go.
 *
 * @return string $prefix
 *   Path to subtree from top-level of repo.
 */
function _site_make_get_prefix($directory) {
  return "projects/{$directory}";
}

/**
 * @param array $details
 *   Relevant details for git subtree add command:
 *
 * @return string | bool
 */
function _site_make_get_uri($details) {
  if (!(isset($details['uri']) || !strlen($details['uri']) > 0)) {
    return drush_set_error('site_make', dt("uri is a required subtree parameter for any subtree included here. Please add this to your site's config file, then try again."), 'error');
  }
  else {
    return $details['uri'];
  }
}

/**
 * @param array $details
 *   Relevant details for git subtree add command:
 *
 * @return string | bool
 */
function _site_make_get_branch($details) {
  if (!(isset($details['branch']) || !strlen($details['branch']) > 0)) {
    return drush_set_error('site_make', dt("branchis a required subtree parameter for any subtree included here. Please add this to your site's config file, then try again."), 'error');
  }
  else {
    return $details['branch'];
  }
}

/**
 * @param string $project_name
 *  Name of project (module, profile, theme, library).
 *
 * @param array $info
 *  Project info array from make files.
 *
 * @return string
 *  Project revision (commit) id specified in make file. False if unavailable.
 */
function _site_make_get_id($project_name, $project_info) {
  $id = (isset($project_info['download']['revision'])) ? $project_info['download']['revision'] : FALSE;

  if (!$id) {
    // If no revision is specified in make file, figure out if this is
    // intentional (someone WANTS to build at the tip of a branch) versus
    // accidental (someone things they're specifying the version a different
    // way).
    
    if (isset($project_info['version'])) {
      $tag = $project_info['version'];
    }
    else if (isset($project_info['download']['tag'])) {
      $tag = $project_info['download']['tag'];
    }

    if ($tag) {
      return drush_set_error('site_make', dt('Commit ID ("revision") unavailable for !name. Please add a line like this to your make file to tell site-make what commit id to check out for version !tag: projects[!name][download][revision] = abc1234 '), array('!name' => $project_name, '!tag' => $tag));
    }

  }

  return $id;
}

/**
 * @param string $project_name
 *  Name of project (module, profile, theme, library).
 *
 * @param array $info
 *  Project info array from make files.
 *
 * @return float | bool
 *  Project version number specified in make file. False if unavailable.
 */
function _site_make_get_tag($project_name, $project_info) {
  $tag = '';

  if (isset($project_info['version'])) {
    $tag = $project_info['version'];
  }
  else if (isset($project_info['download']['tag'])) {
    $tag = $project_info['download']['tag'];
  }
  else if (isset($project_info['download']['revision'])) {
    $tag = $project_info['download']['revision'];
  }

  return $tag; 
}

/**
 * Return command for git subtree merge.
 *
 * Note: This terminology is a little confusing. To "checkout" a particular
 * tagged version for a subtree you need to do a git subtree "merge". There is
 * no subtree checkout command. 
 *
 * @param string $directory
 *
 * @param string $id
 *   Commit id
 *
 * @return string
 *   Git subtree merge command to be executed.
 */
function _site_make_subtree_merge($directory, $id) {
  $prefix = _site_make_get_prefix($directory);
  $message = _site_make_add_subtree_commit_message($details);
  $command = "git subtree merge --squash --prefix={$prefix} {$message} {$id}";
  return $command;
}

/**
 * Return command to generate symlink to subtree.
 *
 * This command must be run from top-level of repo.
 *
 * @param string $name
 *
 * @param string $path
 */
function _site_make_subtree_add_symlink($name, $path) {
  // Get path to subtree, relative to top-level directory.
  $prefix = _site_make_get_prefix($name);
  /*
  // TODO: Find a better place for this error handling only makes sense at runtime. If this is an
  // initial build, or a rebuild with new projects, this will always error out,
  // with the checks being executed here, before the commands actually run.
  // Make sure $path exists.
  if (!file_exists($path)) {
    return drush_set_error('site_make', dt('This directory does not exist: !path'), array('!path' => $path));
  }
  // Make sure the subtree exists.
  if (!file_exists($path)) {
    return drush_set_error('site_make', dt('This subtree prefix not exist: !prefix'), array('!prefix' => $prefix));
  }
  // */

  // Get source, relative to parent directory inside docroot.
  $count = count(explode('/', $path));
  $source = '';
  for ($i = 0; $i < $count -1; $i++) { 
    $source .= '../'; 
  };
  // Add prefix to relative source path.
  $source .= $prefix;

  // Parent directory for symlink.
  $pos = strpos($path, $name);
  $parent_directory = substr($path, 0, $pos);

  // Remove the directory. Replace it with a symlink.
  $command = "rm -rf {$path}; cd {$parent_directory}; ln -s {$source} {$name};";

  return $command;  
}

/**
 * @param string $message
 *
 * @return string $command
 */
function _site_make_commit($message) {
  // Add any new files added to the repo.
  $command = "git add . ; git commit -am '{$message}';";
  return $command;
}

/**
 * Prep projects directory.
 */
function _site_make_prep_projects_directory() {
  // Before adding/pulling subtrees, make sure parent directory for --prefix exists.
  if (!file_exists('projects')) {
    $success = mkdir('projects', 0777, true); 
    if (!$success) {
      return drush_set_error('site_make', dt("Failed creating directory: projects"), 'error');
    }
  }
  else if (file_exists('projects') && !is_dir('projects')) {
    return drush_set_error('site_make', dt("Please remove the 'projects' file. We need to create a directory with that name for your subtrees."), 'error');
  }
  
  if ($success) {
    drush_print('A projects directory has been created at the top of your git repo. Git subtrees will be added there.');  
  }
}

/**
 * Returns array of commands to be executed to add/update a git subtree in a site
 * repo's projects directory.
 *
 * @param array $subtree_name
 *   Config loaded from site make YAML file
 *
 * @param array $details
 *   Config loaded from site make YAML file
 *
 * @param array $project_info
 *   Project info from make file(s)
 *
 * @return array $commands
 */
function _site_make_get_subtree_commands($subtree_name, $details, $project_info) {
  $commands = array();
  
  if($add_subtree =  _site_make_subtree_add($subtree_name, $details)) {
    // Add git subtree if it doesn't already exist.
    drush_print(dt('Preparing to add subtree: !subtree_name', array('!subtree_name' => $subtree_name)), 'status');
    $commands[] = $add_subtree;
  }
  else {
    // Otherwise, pull in any updates.
    drush_print(dt('Preparing to pull subtree: !subtree_name', array('!subtree_name' => $subtree_name)), 'status');
    $commands[] = _site_make_subtree_pull($subtree_name, $details);
  }

  if ($id = _site_make_get_id($subtree_name, $project_info)) {
    drush_print(dt('Preparing to merge !subtree_name subtree to id: !id', array('!subtree_name' => $subtree_name, '!id' => $id)), 'status');
    $commands[] = _site_make_subtree_merge($subtree_name, $id);
  }
  else {
    // @todo Detect latest recommended release on d.o when no version is specified. Consider checking that out to better match standard make file behavior?
    drush_log(dt("No 'revision' specified for !project in makefile(s). Your install will run on the tip of whatever branch you checked out. (Subtrees do not fallback to the latest recommended release on drupal.org when no version is specified.)", array('!project' => $subtree_name)), 'warning');
  }

  return $commands;
}
